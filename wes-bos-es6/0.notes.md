Table of Contents
<!-- MarkdownTOC depth=0 autolink="true" bracket="round" -->

- [Introduction](#introduction)
- [New String Methods](#new-string-methods)
- [scoping var, let, const](#scoping-var-let-const)
	- [var](#var)
		- [declaration hoisting](#declaration-hoisting)
		- [var in loops](#var-in-loops)
		- [global scope](#global-scope)
	- [let](#let)
	- [const](#const)
	- [Temporal Deadzone](#temporal-deadzone)
	- [What to use ?](#what-to-use-)
- [Template Strings](#template-strings)
	- [Tag Functions](#tag-functions)
		- [various uses](#various-uses)
- [Arrow Funcitons](#arrow-funcitons)
	- [Different Formats](#different-formats)
		- [Named arrow functions](#named-arrow-functions)
		- [without any parameters/single parameter](#without-any-parameterssingle-parameter)
		- [with parameters](#with-parameters)
		- [non concise body](#non-concise-body)
		- [returning objects in concise format](#returning-objects-in-concise-format)
	- [arrow functions vs old functions](#arrow-functions-vs-old-functions)
		- [naming](#naming)
		- [the 'this' keyword](#the-this-keyword)
	- [Arrow function - Cautions](#arrow-function---cautions)
- [Default Arguments](#default-arguments)
	- [Lazy Expressions](#lazy-expressions)
	- [Useful cases](#useful-cases)
	- [Using already defined parameters in the list](#using-already-defined-parameters-in-the-list)
	- [A bad code example](#a-bad-code-example)
- [Destructuring](#destructuring)
	- [Destructuring Objects](#destructuring-objects)
		- [Destructuring nested objects](#destructuring-nested-objects)
		- [Merging Objects](#merging-objects)
	- [Destructuring Array](#destructuring-array)
		- [Usage](#usage)
			- [destructuring with default values](#destructuring-with-default-values)
			- [type error with destructuring](#type-error-with-destructuring)
			- [With rest operator](#with-rest-operator)
			- [swapping](#swapping)
			- [Array manipulation \( Dumping variables\)](#array-manipulation--dumping-variables)
			- [Destructing nested array](#destructing-nested-array)
			- [multiple destructuring](#multiple-destructuring)
		- [what not to do](#what-not-to-do)
	- [Destructuring & Function parameters](#destructuring--function-parameters)
- [Iterables and Looping](#iterables-and-looping)
	- [for loop](#for-loop)
	- [forEach](#foreach)
	- [for..in](#forin)
	- [for..of](#forof)
		- [for..of usage](#forof-usage)
		- [what is not iterable](#what-is-not-iterable)
		- [Make Objects iterable](#make-objects-iterable)
- [New  Methods](#new--methods)
	- [Array.from](#arrayfrom)
	- [Array.of](#arrayof)
	- [Array.find](#arrayfind)
	- [Array.findIndex](#arrayfindindex)
	- [Array.some](#arraysome)
	- [Array.every](#arrayevery)
- [...spread and ...rest operator](#spread-and-rest-operator)
	- [spread operator usage](#spread-operator-usage)
	- [...rest usage \(gather\)](#rest-usage-gather)
- [Object literal syntax upgrades](#object-literal-syntax-upgrades)
	- [concise property Names](#concise-property-names)
	- [concise methods](#concise-methods)
	- [computed property names](#computed-property-names)
	- [computed method names](#computed-method-names)
	- [Computed Generator function name](#computed-generator-function-name)
- [Promises](#promises)
	- [creating promise](#creating-promise)
		- [using promises](#using-promises)
		- [Handling multiple promises](#handling-multiple-promises)
- [Symbol - The seventh new data type](#symbol---the-seventh-new-data-type)
- [Code Quality](#code-quality)
	- [how to use in sublime](#how-to-use-in-sublime)
	- [forcing eslint before commit](#forcing-eslint-before-commit)
- [javascript modules](#javascript-modules)
	- [configuring webpack](#configuring-webpack)
	- [Creating Modules](#creating-modules)
	- [systemjs](#systemjs)
	- [babel](#babel)
		- [plugins](#plugins)
	- [Polyfill](#polyfill)
- [Prototypal Inheritance Briefing](#prototypal-inheritance-briefing)
- [Classes](#classes)
	- [static methods](#static-methods)
	- [getters and setters](#getters-and-setters)
	- [using super\(\)](#using-super)
	- [Extending native class](#extending-native-class)
- [Generator functions](#generator-functions)
	- [Use cases for generator functions](#use-cases-for-generator-functions)
	- [for..of with generators](#forof-with-generators)
	- [custom iterators for objects](#custom-iterators-for-objects)
- [Proxies!](#proxies)
	- [Usage](#usage-1)
- [Sets](#sets)
	- [set - methods](#set---methods)
	- [Weak Sets](#weak-sets)
- [Map](#map)
	- [Usage](#usage-2)
	- [WeakMap](#weakmap)
- [Promise - aysnc and wait](#promise---aysnc-and-wait)
	- [Calling multiple promises](#calling-multiple-promises)
	- [Changing with Async Await](#changing-with-async-await)
	- [Awaiting multiple promises](#awaiting-multiple-promises)
	- [Promisifying functions](#promisifying-functions)
- [Class Properties](#class-properties)
- [Padding Strings](#padding-strings)
- [Exponential Operator](#exponential-operator)
- [Trailing/Dangling comma](#trailingdangling-comma)
- [Object.entries\(\) and Object.values\(\)](#objectentries-and-objectvalues)

<!-- /MarkdownTOC -->

# Introduction

- es6 features overview

# New String Methods

- .startsWith('look')
- .endsWith('lookup')
- .includes('lookup string')
- .repeat('number_of_times')
- can be used for padding

# scoping var, let, const

## var

- var is function scoped 

### declaration hoisting

```
function foo(x,y) {
	if( x > y) {
		var tmp = x;
		x = y;
		y = tmp;
	}
}
```

- Functionally the variable 'tmp' is hoisted and scoped to foo
- But synctactically, what the code means is I want the 'tmp' variable to be available only to the if block.

### var in loops

```
for ( var i = 0; i < 10; i++){
	//..
	// functionally means that i should be scoped only to this for block
	// but functionally it's totally different.
	(function(i){
		// binding something or using at a later point in time where i is used
	})(i)
}
```

### global scope

- var can be declared multiple times without errors
- so accidentally the window scoped global variables can be replaced.
- scope gets leaked

```
var RegExp = 'yolo'
```

## let

- block scoped
- cannot be declared multiple times
- replaces iffe's in most places
- makes looping easier
- using let in global scope doesn't replace the values on window object.

## const

- cannot be re-assigned 
- does not mean it's a constant (i.e) values are still mutable
- value can be updated
- usually used for primitive constants
- to really make it a const, use Object.freeze()
- using const may cause confusion.

## Temporal Deadzone 

- let and const variables cannot be accessed before they are defined

## What to use ?

- there is no standard way. Just developer opinions
- There is a recommendation to use const by default and let for things that will change
- There is also recommendation to use var for function scope, let for block scope and const for literal constants


# Template Strings

- this is called as string interpolation in other languages

```
var name = 'Bala';
var orderNumber = "123";
var total = 319.7;

// multi line string
var msg = "Hello, " + name + ", your \
order (#" + orderNumber + ") was $" + 
total + ".";
```

- since single quote and double quote are already use for strings, the new way to interpolate strings is to use backtick.

```
var name = 'Bala';
var orderNumber = "123";
var total = 319.7;


var msg = `Hello ${name}, your
order (#${orderNumber}) was $${total}.`;

//output will actually span multiple lines just as given here
```

- It automatically preserves new lines.
- If that needs to be escaped then use \ like in normal method
- Any legal javascript expression can be put in to those brackets


## Tag Functions

- a tag function accepts the interpolation string as an input
- the strings are split based on the ${someVariable} presence
- Tag function's api
```
function msgFormatter(strings, value1, value2, value3, etc){
	return processedString;
}
```

```
// this function returns the same string
// but lot of formatting can be done with this
function msgFormatter(strings,...values){
	var str = "";
	for (let i = 0; i < strings.length; i++){
		if( i > 0) str += values[i - 1];
		str += strings[i];
	}
	return str;
}
var name = 'Bala';
var orderNumber = "123";
var total = 319.7;


var msg = msgFormatter`Hello ${name}, your
order (#${orderNumber}) was $${total}.`;
```

### various uses

- pre formatting values
- highlight values
- sanitize the values

# Arrow Funcitons

```
(parameter1, parameter2, etc...) => return_value_expression
```

- The above syntax creates an anonymous function and returns the value.
- this is the concise one liner function.

## Different Formats


### Named arrow functions

- arrow functions are anonymous by default

```
var funcName = (param1, param2, ...) => return_value_expression
```

- This syntax makes the js interpreter to automatically inference and set the function name of the returned arrow function to functionName.

### without any parameters/single parameter

- () -- will be just a placeholder, infact any valid name can be used there without any brackets

```
foo = () => 3
console.log(foo())

// similary
foo = x => x
console.log(foo(100))

//even this is valid
foo = _ => 5
console.log(foo())
```

### with parameters

- if there are morethan one parameter then () is required

```
foo = (x,y) => 6
console.log(foo())
```

### non concise body

- the concise body accepts any expression as a valid return statement.
- for any non concise body, the return statement should be explicit
- and it should be contained in curly braces

```
foo = x => { 
  try{ 
    return 3;
  } 
  catch(e) {
    console.log(e);
  } 
}
```

### returning objects in concise format

- to return objects in concise format, it should be enclosed in ()
- this is because when arrow function encounters {} it will be treated as non concise body format.

```
// in this it doesn't return an object instead it returns undefined
foo = x => { y: 5}
console.log(foo())

foo = x => ({ y: 3})
console.log(foo())
```

## arrow functions vs old functions

### naming

- arrow functions are syntactically anonymous, they are named only through name inferencing, that is through guessing the context.
- this might become a problem for identifying errors
- old function can be named when defining them

```
// Promises
p.then( function(v) {return v.id} )
// looks elegant doesn't it?
p.then( v => v.id)
// the problem with this?
// say v is null, v.id will throw exception but in stack trace it'll be anonymous function
// which is hard to debug
// so name it,then it will come with function name in stack trace
// p.then( function extractId(v) {return v.id} )
// advantage :: here the name will be self expressive and easy to debug
```

### the 'this' keyword

- arrow functions do not have their own 'this' keyword.
- so if 'this' keyword is used inside an arrow function, it will simply follow the scope chain to look for this.
- we can consider this as arrow functions inherit the 'this' keyword from it's parent.

- functions inside object

```
var myObj = {
  id: 'adf-3ir9-alkdjfk',
  func: function foo() {
    setTimeout(function(){
      console.log('---time out--')
      console.log(this)
      console.log(this.id)
    },100)
  }
}
```

- here this will be referring to the global window object instead of myObj

```
// people usually pass this as self
var myObj = {
  id: 'adf-3ir9-alkdjfk',
  func: function foo() {
    var self = this;
    setTimeout(function(){
      console.log('---time out--')
      console.log(self)
      console.log(self.id)
    },100)
  }
}
```

- self is just an un creative way of naming
- it should be context instead since that's what it's really referring to

```
var myObj = {
  id: 'adf-3ir9-alkdjfk',
  func: function foo() {
    var context = this;
    setTimeout(function(){
      console.log('---time out--')
      console.log(context)
    },100)
  }
}
```

- what should be really done is bind this to the function

```
var myObj = {
  id: 'adf-3ir9-alkdjfk',
  func: function foo() {
    setTimeout(function(){
      console.log('---time out--')
      console.log(this)
    }.bind(this),100)
  }
}
myObj.func()
```

- using arrow functions, we automatically gets the lexical context this

```
var myObj = {
  id: 'adf-3ir9-alkdjfk',
  func: function foo() {
    setTimeout(() => {
      console.log('---time out--')
      console.log(this.id)
    },100)
  }
}
myObj.func()
```

## Arrow function - Cautions

- because arrow functions doesn't have the 'this' variable call(), apply() and bind() can't be used, so all functions cannot be replaced with => function
- as direct functions inside object - since 'this' will be referring to the global context and not the object itself.
- adding a prototype method and using 'this'
- doesn't have access to arguments

# Default Arguments

- we used to set default values for function arguments like this

```
function foo(x){
	x = x || 42;
	return x;
}

foo() // will return 42
foo(0) // will also return 42 instead of expected 0
```

- this is because || operator will do truthy falsy value test. In this case because of corecion, x will be false
- it should be written as

```
function foo(x) {
	x = x !== undefined ? x : 42;
	return x;
}

foo(0) // will return 0
foo(null) // will return null
```

- null will be a valid value since we are specifically checking for 'undefined'
- the above code can be written with es6 syntax for setting default value as

```
function foo(x = 42) {
	return x;
}

foo() // will return 42
foo(undefined) // will return 42
foo(null) // will return null
```

- the parameter list is block scoped to the function so it's using 'let'

## Lazy Expressions

- How many times will bar be called in the following segment

```
function bar() {
	console.log("!");
}

function foo(x = bar() ){

}
```

- Zero times actually. It's not called until it's necessary for computation

```
foo(10) // bar is not called yet
foo()   // bar is called and computed
foo()   // bar is called and computed again
```

- How many ever times it's needed those many times it'll be called.

## Useful cases

- unique computations

```
function uniqueIdGenerator() {
	//...
}

function foo(x = uniqeIdGenerator() ){

}
```

- check for required parameter

```
function require() {
	throw "Parameter required!!!"
}

function foo(id = required()){

}
```

## Using already defined parameters in the list

- parameter definition goes from left to right
- so it's possible to use a parameter/argument already defined when going left to right

```
function foo( x = 2, y = x){
	console.log(x,y)
}

foo() // will return 2 2
```

## A bad code example

- since using an already defined parameter is possible what happens when it's combined with inline function

```
function foo( x=2, y = function() { return x}){
	console.log(y());
}

foo() // prints 2
```

- but what would happen here

```
var x = 1
function foo( x=2, y = function() { return x}){
	var x = 5;
	console.log(y());
}

foo() // still prints 2
```

- we are supposed to get 5
- x = 2 actually creates a function scoped variable
- so 'var x = 5' doesn't actually create a new function scoped variable instead it'll be considered like an assignment 'x = 5'.
- so when the anonymous function y was declared, it takes the current value of x which is 2.

# Destructuring

## Destructuring Objects

```
var { 
	objectKey1: "variable name where the objectKey's value should be stored" 
} = someObject
```


- allow us to extract property values from objects
- this can be nested
- defaults can be set

- we used to do it like this

```
function getDetails() {
	return {
		name: 'bala',
		age: 28,
		role: 'software engineer'
	}
}

var personName, personAge, personRole;

var personData = getDetails();

personName = personData.name;
personAge = personData.age;
personRole = personData.role;
```

- The above can be done as

```
var {
		name: personName,
		age: personAge,
		role: personRole
} = getDetails()
```

- when object destructuring is used without 'var' declaration, it needs to be wrapped in paranthesis as it will be considered as assigning something to object literal syntax and not qualify as a valid expression.
- It follows the object literal syntax where the left part denotes the keyName and the right part denotes the KeyValue. Similarly while destructuring, the keyName is specified on the left side and the variable where the value of the specified keyName should be stored to.
- If the keyname and the varaible name we want to store the value are the same, we can do it even more simpler like this.

```
var { name, age, role} = getDetails()
```

- This will extract the value of key 'name' from the object returned by getDetails and store it in a variable with the same name
- It's same as this

```
var name, age, role;
(
	{
		name: name,
		age: age,
		role: role
	} = getDetails()
)
```

### Destructuring nested objects

```
function getDetails() {
	return {
		name: 'bala',
		age: 28,
		role: 'software engineer',
		address: {
			line1: 'Private Corporation Ltd',
			line2: 'Indra Nagar',
			city: 'Bangalore'
		}
	};
}

var {
	name, 
	age, 
	role: personRole = 'IT Professional',
	role: roleCopy,
	address: {
		line1: address1,
		line2: address2,
		city
	} = {} ,
	randomKey: randomVal = 100
} = getDetails() || {};
```

- the abscence of a property behaves as 'undefined'
- if a nested expected object is not defined in the object it'll throw the same type error, so it should be default.
- this is how it'll search
	- look for the key
	- check for default value
	- then do destructuring of pattern

### Merging Objects


```
var defaults = {
	method: "POST",
	callback: function() {},
	headers: {
		"content-type": "text/plain"
	}
};

var config = {
	url: "http://some url",
	callback: foo,
	headers: {
		"x-requested-width": "foo"
	}
}
```

Merging two hashes can be done like this through destrucutring

```
let {
	method = defaults.method,
	url,
	callback = defaults.callback,
	headers: {
		"content-type": contentType = defaults.headers["content-type"],
		"x-requested-with": xRequestedWith
	}
} = config;

config = {
	method,
	url,
	callback,
	headers: {
		"content-type": contentType,
		"x-requested-with": xRequestedWith
	}
}
```


## Destructuring Array

```
function foo() {
	return [1,2,3];
}

var tmp = foo();
var a = tmp[0];
var b = tmp[1];
var c = tmp[2];
```

- this can be done as
```
function foo(){
	return [1, 2, 3];
}

var [a, b, c] = foo();
// to make it readable
var [
	a,
	b,
	c, // trailing comma is allowed
] = foo();
// easier to make out the diff as well
```

- that is not an array.
- it simply means the assignment is expecting a value on the right hand side with the pattern defined on the left hand side
- when the variable defined in the expected pattern is not exact as the value, it's simply ignored when it's more than what was expected or assigned as undefined when the value contains less stuff than expected

```
var a,b,c;

[
	a,
	b,
	c,
] = [1,2,3,4]
// extra value 4 is ignored

[
	a,
	b,
	c,
] = [1]
// values not found are assigned as undefined

```
- anything that is a valid assignment target can be put in that pattern

```
var x= [ 'name', 'dob', 'detail1', 'detail2'];
var person = {};
[
	person.name,
	person.dob,
	person.detail1,
	person.detail2
] = x;
```
### Usage

- very helpful when working with api responses

#### destructuring with default values

```
function foo()
	return [1];
}

var tmp = foo();
var a = tmp[0];
var b = tmp[1] !== undefined ? tmp[1] : 42;
var c = tmp[2]
```

- can be simplified with destructuring as

```
function foo() {
	return [1];
}

var [
	a,
	b = 42,
	c,
] = foo();
```

#### type error with destructuring

```
function foo() {
	return null;
}

var [
	a,
	b,
	c
] = foo() || [];
```

#### With rest operator

```
function getPersonDetails() {
	return ['bala', 'software engineer', pramata', '4th floor', salarpuria citadel', 'bangalore' ];
}

var person = {};
[
	person.name,
	person.role,
	person.org,
	...person.address
] = getPersonDetails();
```

#### swapping

```
var x = 10, y  20;

[x,y] = [y,x];
```

#### Array manipulation ( Dumping variables)

```
var a = [1,2,3];
var x,y;
[
	x, 
	y,
	...a
] = [ 0, ...a, 4];
```

- ignore first 2 elements

```
[ , , ..a] = a
```

#### Destructing nested array

```
function foo() {
	return [ 1, 2, 3, [4, 5, 6]];
}

var a, b, c, vals, d, e;

[
	a,
	b,
	c,
	...vals
] = foo();
// here vals = [[4, 5, 6]]
	
[
	a,
	b,
	c,
	[
		d,
		e
	]
] = foo();
```

- implicitly uses array indexes for matching with the pattern

#### multiple destructuring

- since destructuring is just pattern matching on assignments

```
[a, b] = [,,...args]
```

### what not to do 

- Destructuring is not an array, it's just pattern matching on assignments.

```
var x = [ a, b] = [ 1, 2, [3, 4, 5]]
// here x will not have [ 1, 2] but the whole array [1, 2, [3, 4, 5]]
```

- but this is possible

```
function foo(){
	return [1, 2, 3, [4, 5, 6] ];
}

var a, b, c, d, vals;
[ , , ,[c] ]  = [a, b, , ...vals] = foo()
```

- one thing to note is var applies only to the left most variables.

## Destructuring & Function parameters

- Both array and object destructuring is applicable to function parameters since it's essentially an assignment

```
function foo( [a, b, c] ) {
	console.log(a, b, c);
}

foo( 1, 2, 3); // will throw error

foo( [1, 2, 3] );
```

- when a function is having morethan two or three parameter it is better to replace it with object destructuring


# Iterables and Looping

```
const names = ['luffy', 'light', 'goku', 'batman', 'superman']
```

## for loop

```
for(const i = 0; i < names.length; i++){
	console.log(name[i])
}
```

## forEach

```
names.forEach((name) => {
	console.log(name);
});
```

## for..in

```
for( const index in names) {
	console.log(names[index]);
}
```

- It also iterates over the prototype properties and all the other values

## for..of

```
for(const name of names)}{
	console.log(name);
}
```

### for..of usage

- Array, String, Map, Set and DomCollection and any object with Symbol.iterator prop defined are iterable as of now.
- if you call names.entries() you would see that it's returning an object called ArrayIterator with a function called next.
- That object is called an iterator
- we can call that function 
```
const nameIterator = names.entries();

nameIterator.next()
// returns an object with two properties
// {
//	 value: <the next array value from current postion
//	 done: false -- tells whether all the elements are iterated already
// }
```

- if we loop over the iterator with for..of
```
for(const name of names.entries()){
	console.log(name);
}
// will output [ arrayIndex, arrayvalueAtIndex]
// [0, 'luffy']
```

- we can use destructuring along with it
```
for(const [index, name] of names.entries()){
	console.log(index, name);
}
```

- can be used for arguments inside functions..
- arguments is an array like object but not an actual array. You can understand this if you look at it's __proto__ property.
- if you put it console you can see that it has a property Symbol.iterator
- this property is a function which makes an object iterable

```
function add(){
	let total = 0;
	for(const num of arguments){
		total += num;
	}
	return num;
}

// it's better to do this with
// convert arguments to array and use reduce
// use rest operator and reduce
```

- can be used for String since it is also iterable

```
const name = 'BalaManohar.B';
for(const char in name){
	console.log(char);
}
```

- loop over DOM elements

```
const ps = document.querySelectorAll('p');
//this will return a NodeList not an array but it is still iterable since it has the Symbol.iterator prop defined.
for(const paragraph of ps){
	paragraph.addEventListener('click', function(){
		console.log(this.textContent);
	})
}
```

### what is not iterable

- plain Objects are not iterable since it doesn't have Symbol.iterator defined.
- However there is a propsosal for Object.entries/ Object.values in TC39 which in stage 4.
- So we can use polyfills with entries.

```
const fruit = {
	name: 'apple',
	color: 'red',
	size: 'medium',
	weight: 50,
	sugar: 10
}

for ( const prop of Object.keys(fruit)){
	const value = apple[prop];
	console.log(value, prop);
}
```

- it's better to use for..in instead till we have for..of defined for Objects

### Make Objects iterable

- an iterator has next() method

```
var obj = {
	//concise method
	[Symbol.iterator]() {
		var index = this.start, en = this.end;

		var it = {
			//since we need to access this
			next: () => {
				if( index <= en) {
					var v = this.values[index];
					index++;
					return { value: v, done: false }
				}
				else{
					return { done: true}
				}
				
			}
		}

		return it;
	},
	values: [ 2, 4, 6, 8, 10, 12, 14, 16, 18, 20],
	start: 4,
	end: 9

}

//now this object can called on spread 

var vals = [ ...obj ]
```



# New  Methods

- These methods 'from' and 'of' are not on the Array.prototype but on the Array object itself.
- This means actual array objects will not have them.
- converts array like objects to an actual array.

## Array.from

- signature

```
Array.from(arrayLikeObject, mapFunctionForConvertedArray);
```

- map function is optional

- convert document nodeList to array.

- arguments

```
function sumAll() {
	const nums = Array.from(arguments);
	return nums.reduce((prev, next) => prev + next, 0);
}
sumAll(2,194,12,3948,1934);
```

## Array.of

- creates an array from list of comma seperated parameters and returns it

```
Array.of(comma seperated values);
```

## Array.find

- available on array prototype
- similar to filter except it returns the first value from the array where the function returned true

```
//find first even number
const nums = [1,2,3,4,5,6,7];
const firstEven = nums.find(num => num % 2 === 0)
```

## Array.findIndex

- similar to find except it returns arrayIndex instead of the value

```
//find first even number
const nums = [1,2,3,4,5,6,7];
const firstEvenIndex = nums.findIndex(num => num % 2 === 0)
```

## Array.some

- returns true if at least one element is present satisfying the condition

```
//check if the array has atelast one even number
const nums = [1,2,3,4,5,6,7];
const isEvenPresent = nums.some(num => num % 2 === 0)
```

## Array.every

- returns true if all elements of the array satisfies the condition of the function

```
// check if all elements present in are array
const nums = [2,4,6,8,10];
const isAllNumsEven = nums.some(num => num % 2 === 0)
```

# ...spread and ...rest operator

- used on any object that is iterable on assignment context
- assignment context any place where a value is getting assigned to a variable.
- the ... operator consumes iterators, so there are only two places it can go. array literals and function arguments
- destructuring also consumes iterators internally


## spread operator usage

- spread the iterable object into seperate values, (i.e) unpacks an iterable object.

- copy an array into another array instead of mistakenly using object reference
```
const nums = [1,2,3];
const numsCopy = nums;
//changing numsCopy will affect nums as well since numsCopy is just a reference and not an actual copy of values
```
- instead use it like this

```
numsCopy = [...nums];
```

- copy multiple arrays
- concat multiple arrays with some values in middle.

```
multiArray = [...arr1, someValue1, someValue2, ...arr2]
```

- pass an array as a list of parameters to function

```
function printName(fName,lName){
	return `Hi there, ${fName} ${lName}`
}

var name = ['Light', 'Yagami']

console.log(printName(...name))
```

- make string to a char array

```
let str = 'spreadme'
let strArr = [...str]
```

- can be combined with destructuring

- to ignore, remove elements from an array.

## ...rest usage (gather)

- ... can be used at the recieving end (i.e) used for collecting or packing a un packed object

```
function sum(...nums){
	return nums.reduce((prev, cur) => prev + cur, 0)
}

console.log(sum(1,2,3,4,5,6,9))
```

- can be combined with destructuring

# Object literal syntax upgrades

## concise property Names
- if property name and variable name of value we are storing are same, we can do it like this

```
let fName = 'Light';
let lName = 'Yagami';
let series = 'DeathNote';

let charDetail = {
	fName,
	lName,
	series
};
```

## concise methods

- can loose the colon and function key words
- have to remember that this is the old function and not the new arrow function, so the 'this' keyword will work as usual.

```
let objectName = {
	functionName() {
		//do something here
	}
}
```

- concise methods do not have self reference so, they can't be used for functions that calls itself inside it since they are lexically anonymous
- this is because 

```
// this is perfectly legal
var objName = {
	"hello world"() {
		//can't come up with a name to self infer for this case
	}
}
```


## computed property names

- when the property name is a value stored in a variable
- we used to do like this

```
let propName = 'prop1';
let propVal = 'myVal'
let myObj = {};

myObj[propName] = propVal;
```

- it can be done like this

```
let propName = 'prop1';
let propVal = 'myVal'
let myObj = {
	[propName] : propVal
};
```

- any value javascript expression can replace propName

```
let keys = ['size', 'color' ];
let vals = ['medium', 'red'];
let tShirt = {
	[keys.shift()]: vals.shift(),
	[keys.shift()]: vals.shift()
}
```

## computed method names

- It's bit confusing to use this.

```
var someFuncName = 'someGetter';

var obj = {
	[someFuncName]() { },
	//any valid expression can be put in those brackets
};
```

## Computed Generator function name

```
// Normal generator function
var obj = {
	foo: function*() {}
}

//concise generator

var someGeneratorName = 'someFuncName'

var obj =  {
	*foo() {},
	//normal generator function
	*[someGeneratorName]() { }
	// computed generator function
}
```

# Promises

- kind of like an iou object for async stuff
- when we use fetch statement, a promise is return
- we can pass a callback function, to the promise.

```
let resp = fetch('some url');

resp.then(data => data.json())
.then(//process data)
.catch((err) => {
	//process error
})
```

- it's basically like async response

- But how do return our own promise objects ?

## creating promise

- usually some time counsuming process is run inside promise

- resolve to return processed to data
- reject raise exception

```
const p = new Promise((resolve, reject) => {
	setTimeout(() => {
		resolve("I'm returning some data from promise");
	}, 1000)
	
})

p
	.then(data =>{
		console.log(data);
	})
```

### using promises

- when we need flow control
- usually in the backend like nodejs

```

function getDataFromDB(id) {
	//create a new promise
	return new Promise((resolve, reject) => {
		//fetch data from db
		//do something with the data, pass it to a function may be or return it directly
		if(checkData()){
			resolve(data)
		}
		else{
			reject(Error('Data not found'));
		}
	})
}

//processor function
function processPromise(){
	getDataFromDB('47294')
		.then(data => data.json())
		.catch(err => {
			//handle error
		})
}
```

### Handling multiple promises


```
const promise1 = fetch('json_response_url_1');
const promise2 = fetch('json_response_url_2');

Promise
	//this one gets triggered only when we get data for all the promises mentioned in here
	.all([promise1, promise2])
	.then(rawResponses => {
		//process the raw response 
		return rawResponses.map( resp => resp.json())
	})
	.then(json_responses => {
		// process the json formatted data
	})
	catch(err => {
		// do something with the error
	});
```

# Symbol - The seventh new data type

- symbol is a unique globally unguessable value within the context of a program
- it is never revealed to the user.
- usually used when prop name collision is expected.
- the label is just a description. it can be same.

```
const someVar = Symbol('a label');
```


```
const bala = Symbol('person');
const person = Symbol('person')
```

- Symbols aren't enumerable so it will not come in for..in
- because of this it's used in private variables as well
- But if we still want to get all the symbols in an object

```
const calssRoom = {
	[symbol('adam')]: {gender: 'male', region: 'unknown'},
	[symbol('adam')]: {
		gender: 'male', region: 'genesis'
	}
}

//this won't print anything
for( person in classRoom){
	console.log(person);
}

//to get all the symbol keys of an object
const syms = Object.getOwnPropertySymbols(classRoom);
console.log(syms);
// to get the data
const data = syms.map(sym => classRoom[sym]);
console.log(data);

```

# Code Quality

- ESLint
- Different from JSHint & JSLint

```
npm install -g eslint

> eslint file_path
```

- customizable through custom rules in .eslintrc
- this is a json file which contains the rules for linting

```
{
	"env": {
		"es6": true,
		"browser": true,
		"node": true
	},
	"extends": "eslint:recommended",
	//over riding extending rules
	"rules": {
		"no-console": 2 //options
	}
}
```

- airbnb's style guide 

https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb

- see installation guide
- after installing extend airbnb instead eslint default
- customize it if needed

- fixing space

```
eslint <filepath> --fix
```

- setting globals like library variables
- put this at the beginning of the js file.

```
/* globals twttr */
```

- polyfilling, overriding prototypes
- put this at the beginning of the file

```
/* eslint-disable no-extend-native */
```

- putting it at the beginning of the will apply for the entire file

- sometimes we might need it just for a particular in that case, just include it before the block and enable again like this

```
/* eslint-disable */
// copied function from somewhere
/* eslint-enable */
```

- there are many plugins for the type of file we write

- awesome eslint collection

https://github.com/dustinspecker/awesome-eslint

## how to use in sublime

- install eslint globally
- install sublimelinter plugin - this is a frame work for all other linters
- install sublimelint-contrib-eslint

## forcing eslint before commit

- we can make that by adding checks in hooks
- hooks are points in git process
- we can put our check in commit check
- .git/hooks/ folder contains all the hooks
- you can see .git/hooks/commit-msg.sample for example
- make a file .git/hooks/commit-msg
- put this code into that file

```
#!/bin/bash
files=$(git diff --cached --name-only | grep '\.jsx\?$')

# Prevent ESLint help message if no files matched
if [[ $files = "" ]] ; then
  exit 0
fi

failed=0
for file in ${files}; do
  git show :$file | eslint $file
  if [[ $? != 0 ]] ; then
    failed=1
  fi
done;

if [[ $failed != 0 ]] ; then
  echo "ðŸš«ðŸš«ðŸš« ESLint failed, git commit denied!"
  exit $failed
fi

```

# javascript modules

- just importing functions from other file or libraries
- but browsers don't support this natively so we need a bundler to bring them together.
- package.json - configuration of libraries/ packages involved
- webpack bundles everything and creates a single js file.

## configuring webpack

 -First Install your dependencies:

```bash
npm install webpack@beta babel-loader babel-core babel-preset-es2015-native-modules --save-dev
```

- Then, Create a `webpack.config.js` file:

```js
const webpack = require('webpack');
const nodeEnv = process.env.NODE_ENV || 'production';

module.exports = {
  devtool: 'source-map',
  entry: {
    filename: './app.js'
  },
  output: {
    filename: '_build/bundle.js'
  },
  module: {
    loaders: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'babel-loader',
        query: {
          presets: ['es2015-native-modules']
        }
      }
    ]
  },
  plugins: [
    new webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: false
      },
      output: {
        comments: false
      },
      sourceMap: true
    }),
    new webpack.DefinePlugin({
      'process.env': { NODE_ENV: JSON.stringify(nodeEnv) }
    })
  ]
};
```

- Setup the build npm script in `package.json`:

```json
"build": "webpack --progress --watch"
```

## Creating Modules

- variables are always scoped to that module at the top level.
- before we can use any thing from a module, it should be exported.
- there are two types of exports
  - default export - can be imported as any name we like, usually used for the main 
thing that the module does
    - only one default export is allowed per file.
    - only default exported can be imported without any curly braces

```
// config.js file
// default export
const apiKey = 'aabc18483';
export default apiKey
```

- it will be imported like this

```
// .js is not needed here
import myApiKey from 'config'
// any name could be used instead of myApiKey
```

- named export - should be imported with the name it was exported as.
	- no restrictions on the number of named exports
	- it must be imported with in { } - this is not destructuring - just the syntax used by transpilers
	- can be imported with a different name using 'as'

- consider the file

```
// config.js file
// named exports
export default const entityId = '48rkcmw9c93wwe9ciwmr30dkkc8393'
export const apiKey = 'abcd'
export conts url = 'some api url'
export function sayHi(name) {
	console.log(`Hello here ${name}`);
}
const age = '70'
const area = 'adugodi'

export { age as oldAge, area };
```

- can be imported like this

```
import entityId, { apiKey, url as apiUrl, say Hi } from 'config'

//.js is not needed
//import both default and named exports
```

## systemjs

- it enables us to run without webpack precompiling and bundling
- this is a library which dynamically bundles 
- useful for fast testing or proof of concepts
- works only on server
- sample

```
//html page
<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>
<script src="https://jspm.io/system@0.19.js"></script>
<script>
	System.config({ transpiler: 'babel' });
	System.import('./main.js');
</script>

//js importing from npm directly
import {sum, kebabCase} from 'npm:loadash'
```

## babel

- a javascript compiler
- since many browsers out there haven't implement es6 features, babel is needed

```
npm init
// creates package.json with initial set up for a javascript project
```


- [checkout babel repl](https://babeljs.io/repl/)

```
npm install bable-cli@next
//include next to install the latest version (beta)
```

- this will automatically add it to the 'package.json'

### plugins

- [babel plugins](https://babeljs.io/docs/plugins/)
- every js feature is listed as plugin for compiling them into es5
- a preset is a collection of plugins
- instead of listing the plugins one by one we can use preset.
- babel-preset-env is preset which is based on environment we are going to support like chrome browser, node etc..

```
npm install bable-preset-env
```

- instead of including a seperate .babelrc configuration, it can be added to package.json file itself by including 'babel' key

## Polyfill

- transpiler only converts the es6 syntax to es5
- but there are es6 methods
- these needs to be implement by us where the browsers don't support.
- usually mdn repo lists the polyfills for all methods.
- but this can be managed by polyfill scripts.
  - polyfill.io
    - this detects the user agent and sends the respective polyfill for it
  - babel polyfill

# Prototypal Inheritance Briefing

```
//constructor function

fuunction Adt(name){
	this.name = name;
}

let customArray = new Adt('customArray');
customArray.toString();
// customArray.toString is still acessible here

Adt.prototype.toString = function(){
	console.log('custom to String method');
}
```

# Classes

```
class Adt {
	constructor(name) {
		this.name = name;
	}
	// comma is not needed

	toString() {
		console.log('this is a custom toString method');
	}
}

let customArray = new Adt('customArray');
customArray.toString();
```

## static methods

- similar to Array.of and Array.from
- these are similar to class methods in ruby.
- can be called only on the class directly

```
class Adt {
	static info() {
		console.log('This is a class for creating custom abstract data type');
	}
}

let customArray = new Adt();
customArray.info()
// this will throw error since it can be called only on Adt itself.
```

## getters and setters

```
class Adt {
	get description() {
		return `this is ${this.name} object created out of Adt`;
	}
	set name(value) {
		this.name = value;
	}
	get name() {
		return this.name;
	}
}

let customArray = new Adt('customArray');
customArray.name = 'newArray';
```

## using super()

```
class Animal {
	constructor(name) {
		this.name = name;
		this.thirst = 100;
		this.belly = [];
	}

	drink() {
		this.thirst -= 10;
		return this.thirs;
	}

	eat(food) {
		this.belly.push(food);
		return this.belly;
	}
}

class Dog extends Animal {
	constructor(name, breed) {
		super(name);
		// before using this - super must be 
		this.breed = breed;
	}

	bark() {
		console.log('Woof Woof');
	}
}

let rhino = new Animal('Rhiney');

rhino.eat('shawarma roll');
let snickers = new Dog('snickers', 'King Charles');
```

- it's a good practice to not deeply extend.

## Extending native class

```
  class MovieCollection extends Array {
    constructor(name, ...items) {
      super(...items);
      this.name = name;
    }
    add(movie) {
      this.push(movie);
    }
    topRated(limit = 10) {
      return this.sort((a, b) => (a.stars > b.stars ? -1 : 1)).slice(0, limit);
    }
  }

  const movies = new MovieCollection('Wes\'s Fav Movies',
    { name: 'Bee Movie', stars: 10 },
    { name: 'Star Wars Trek', stars: 1 },
    { name: 'Virgin Suicides', stars: 7 },
    { name: 'King of the Road', stars: 8 }
  );

  movies.add({ name: 'Titanic', stars: 5 }); 
```


# Generator functions

- a function which can be started and paused
- returns the next element in an object

```
{
	value: 'someval',
	done: 'true or false' // denotes if all elements are done.
}
```

- pause, unpause, get/yield, pause again

```
function *main() {
	console.log("hello");
	yield 10;
	console.log("hello again");
	yield 11;
}

// when main is called
// instead of executing it returns an iterator

var it = main()

it.next() // returns { value: 10, done: false} and pauses at line yeild 10
it.next() // returns { value: 11, done: false}
it.next() // returns { value: undefined, done: true}

```


- a loop with yield

```
function* incrementor(){
	let count = 1;
	while(true){
		yield count++;
	}
}

let counter = incrementor();
counter.next();
```

## Use cases for generator functions

- using ajax calls in sequence. (i.e) when the next call depends on the response of previous call.
- usually we do this with call back which often results in callback hell.


## for..of with generators

```
 function* lyrics(){
 	yield `But don't tell my heart`;
	yield `My achy breaky heart`;
	yield `I just don't think he'd understand`;
	yield `And if you tell my heart`;
	yield `My achy breaky heart`;
	yield `He might blow up and kill this man`;
  }

const achy = lyrics();

for (const line of achy) {
	console.log(line);
}
```

## custom iterators for objects

- generators make it easier to write custom iterators

```
var obj = {
	//concise method
	*[Symbol.iterator]() {
		for(let i = this.start; i <= this.end; i++){
			yield this.values[i];
		}
	},
	values: [ 2, 4, 6, 8, 10, 12, 14, 16, 18, 20],
	start: 4,
	end: 9

}

//now this object can called on spread 

var vals = [ ...obj ]
```


# Proxies!

- allows to override the default behavior of an object.
- [proxy mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)

## Usage

- can do something like trim before setting value;
- can format when getting
- put checks for setters

# Sets

- similar to array 
- is collection which stores only unique elements.
- it is not based on index like array, however it is iterable

## set - methods

- add // add new value
- clear // empty the set
- delete 
- keys // returns iterator
- values // returns iterator
- has // check if the element exists

## Weak Sets

- can only contain objects
- is not iterable i.e cannot be used in for..of
- if the object stored in weak set is garbage collected i.e no longer used then it is removed from the weak set automatically

# Map

- similar to objects
- has key value pairs

```
let phonebook = new Map();

phonebook.set('Clark', 384930482);
phonebook.set('Kent', 739209384);

phonebook.forEach((val, key) => console.log(val, key));

for(const [key,val] of phonebook) {
	console.log(key,val);
}

phonebook.clear(); // empty the object
```

## Usage

- it can have objects as keys.
- used for storing meta information about an object (i.e) usually dom nodes.

## WeakMap

- it doesn't have size
- is not enumerable.
- similar to WeakSet.
- automatically deletes garbage collected objects

# Promise - aysnc and wait

```
document.write('<video controls class="video_element"></video>')
const video = document.querySelector('.video_element');

navigator.mediaDevices.getUserMedia({ video: true }).then(mediaStream => {
  video.srcObject = mediaStream;
  video.load();
  video.play();
}).catch(err => {
  console.log(err);
})
```

## Calling multiple promises

```
function breathe(amount) {
  return new Promise((resolve, reject) => {
    if (amount < 500) {
      reject('That is too small of a value');
    }
    setTimeout(() => resolve(`Done for ${amount} ms`), amount);
  });
}

breathe(1000).then(res => {
  console.log(res);
  return breathe(500);
}).then(res => {
  console.log(res);
  return breathe(600);
}).then(res => {
  console.log(res);
  return breathe(200);
}).then(res => {
  console.log(res);
  return breathe(500);
}).then(res => {
  console.log(res);
  return breathe(2000);
}).then(res => {
  console.log(res);
  return breathe(250);
}).then(res => {
  console.log(res);
  return breathe(300);
}).then(res => {
  console.log(res);
  return breathe(600);
}).catch(err => {
  console.error(err);
  console.error('YOU SCREWED');

})
```

## Changing with Async Await

- it's built on top of promises.
- it can't be used at the top level.
- must be in a function which is marked as async

```
function breathe(amount) {
  return new Promise((resolve, reject) => {
    if (amount < 500) {
      reject('That is too small of a value');
    }
    setTimeout(() => resolve(`Done for ${amount} ms`), amount);
  });
}

function catchErrors(fn) {
  return function (...args) {
    return fn(...args).catch((err) => {
      console.error('Ohhhh nooo!!!!!');
      console.error(err);
    });
  }
}

async function go(name, last) {
  console.log(`Starting for ${name} ${last}!`);
  const res = await breathe(1000);
  console.log(res);
  const res2 = await breathe(300);
  console.log(res2);
  const res3 = await breathe(750);
  console.log(res3);
  const res4 = await breathe(900);
  console.log(res4);
  console.log('end');
}

const wrappedFunction = catchErrors(go);

wrappedFunction('Light', 'Yagami');
```

## Awaiting multiple promises

```
// async function go() {
//   const p1 = fetch('https://api.github.com/users/wesbos');
//   const p2 = fetch('https://api.github.com/users/stolinski');
//   // Wait for both of them to come back
//   const res = await Promise.all([p1, p2]);
//   const dataPromises = res.map(r => r.json());
//   const [wes, scott] = await Promise.all(dataPromises);
//   console.log(wes, scott);
// }

// go();

async function getData(names) {
  const promises = names.map(name => fetch(`https://api.github.com/users/${name}`).then(r => r.json()));
  const people = await Promise.all(promises);
  console.log(people);
}

getData(['wesbos', 'stolinski', 'darcyclarke']);
```

## Promisifying functions

```
// navigator.geolocation.getCurrentPosition(function (pos) {
//   console.log('it worked!');
//   console.log(pos);
// }, function (err) {
//   console.log('it failed!');
//   console.log(err);
// });

function getCurrentPosition(...args) {
  return new Promise((resolve, reject) => {
    navigator.geolocation.getCurrentPosition(...args, resolve, reject);
  });
}

async function go() {
  console.log('starting');
  const pos = await getCurrentPosition();
  console.log(pos);
  console.log('finished');
}


go();
```

# Class Properties

- not a part of es6 yet but heavily adopted by react community and bable supports this.

[Class Properties](https://babeljs.io/docs/plugins/transform-class-properties/)


# Padding Strings

- helps in alignment purposes

```
'test'.padStart(5);
'test'.padEnd(10);
```

# Exponential Operator

- **
- can be used as a replaced with **

# Trailing/Dangling comma

- usefull for git diff

```
const names = [
  'wes',
  'kait',
  'lux',
  'poppy',
];

const people = {
  wes: 'Cool',
  kait: 'EVen Cooler!',
  lux: 'Coolest',
  poppy: 'Smallest',
  snickers: 'Bow wow',
}

function family(
  mom,
  dad,
  children,
  dogs,
) {
	// do something here
}

```

# Object.entries() and Object.values()

- new static methods on object

```
const inventory = {
  backpacks: 10,
  jeans: 23,
  hoodies: 4,
  shoes: 11
};

// Make a nav for the inventory
const nav = Object.keys(inventory).map(item => `<li>${item}</li>`).join('');
console.log(nav);

// tell us how many values we have
const totalInventory = Object.values(inventory).reduce((a, b) => a + b);
console.log(totalInventory);

// Print an inventory list with numbers
Object.entries(inventory).forEach(([key, val]) => {
  console.log(key, val);
});

for (const [key, val] of Object.entries(inventory)) {
  console.log(key);
  if (key === 'jeans') break;
}
```

- cannot break away in forEach